只专注于C++11的话，一个表达式只有两种值类型，LValue和RValue。

#### LVaule
左值，是指那些在内存中可以通过地址访问到的变量，通常也就是在代码中有标识符(identifier)的变量，也就是认知中最常见的变量。

#### RVaule
和左值相对应的右值，是指在内存中不能够通过标识符访问到的变量。这样的变量通常只是暂时存在和使用，比如用来初始化一个变量。
```c++
int i = 42; // i is Lvaule, 42 is Rvalue
int *p = &i; // p is Lvaule, &i is Rvalue
```

#### LVaule Reference
最通俗的理解，左值引用是内存中某个对象的别名。
也可以理解为，栈区对象的引用相当于堆区对象的指针。当我们对引用做修改的时候，也就相当于对引用的对象做修改。
利用引用的好处是，省去了数据拷贝的步骤，提升了效率。

#### RVaule Reference
对于右值来说，我们通常没有办法通过它们的地址去访问他们。因此，C++11首次引入了右值引用的概念，可以允许用户去访问内存中的临时变量。
右值引用的写法如下：
```c++
int &&j = 42;
```
以上面的例子，当代码执行成功了之后，我们就可以访问内存中存储数字42的地址。因此，我们把临时右值42转换成了左值变量j，这种转换一直持续到右值引用失效为止。

使用右值引用的原因是，通过节省拷贝操作的开销提升程序运行效率。比如下面的赋值语句，在没有右值引用的情况下需要经过如下步骤。
```c++
int m = k + l; // m = Lvalue, l+k = Rvalue
```
1. 在内存中创建左值变量m
2. 计算k+l的和，并将结果按照右值存储在内存中
3. 存储起来的临时变量被拷贝到m的地址中。在某个时刻，这个值被创建两次。
4. 最后临时变量被释放，系统可以删除该变量

当使用右值引用的时候：
```c++
int &&m = k + l; // m = Rvalue Reference
```
1. 在内存中创建右值引用m
2. k+l计算结果临时变量的地址直接赋值给m，没有拷贝和销毁过程