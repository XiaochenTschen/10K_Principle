forward只有一个使用场景：将模板函数的数据类型根据调用时传入的参数cast为正确的数据类型(左值或者右值)。
这种方法可以让右值参数被cast为右值，左值参数被cast为左值，所以也被成为"perfect forwarding".

要理解forward的使用方法，还需要理解下面的几个概念。

#### 引用折叠
类型折叠，用于确定在模板实例化或类型别名声明(比如一个引用的引用)的最终类型。其规则只有如下两条：
1. 左值引用到左值引用的折叠: 'T& &&', 'T& &', 'T&& &' --> 'T&'
2. 右值引用到右值引用的折叠: 'T&& &&' --> 'T&&'

从上面的例子可以看出，其实不存在引用的引用，而且左值引用始终优先，如果有任何左值引用参与折叠，结果一定是左值引用。

#### 模板类型推导
类型推导，是指编译器根据传递给模板函数的实参，自动确定形参类型的过程。当调用一个模板函数但不显式指定模板参数的时候，编译器就会尝试推导这些参数。类型的推导主要涉及三种情况。

1. 如果模板参数是一个非引用类型 T，编译器会根据传入的参数类型来推导 T。如果传入的是一个引用类型，编译器会忽略引用部分来推导 T。
```c++
template<typename T>
void foo(T param);

int x = 42;
foo(x); // T is int
```

2. 如果模板参数是一个左值引用类型 T&，那么传入的参数可以是左值或者 const 或/和 volatile 左值。
```c++
template<typename T>
void foo(T& param);

int x = 42;
int const cx = 40;
foo(x);  // T is int
foo(cx); // T is const int
```

3. 如果模板参数是一个右值引用类型 T&&（通用引用），类型推导会根据传入参数是左值还是右值来决定 T 的类型。
```c++
template<typename T>
void foo(T&& param);

int x = 42;
foo(x);              // T 被推导为 int& （因为 x 是左值）
foo(std::move(x));   // T 被推导为 int  （因为 std::move(x) 是右值）
```
