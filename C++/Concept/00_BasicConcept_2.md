`
#### Type && Value Category

Type类型是比较通用的概念，比如一个变量是int还是double类型之类。

Value category值类别将表达式的值细分为三种核心概念：左值(lvalue)，将亡值(xvalue, "eXpiring" value)，纯右值(prvalue, "pure" rvalue)。
合并起来可以归为两大类： glvalue(generalized lvalue) = lvalue+xvalue, rvalue = prvalue+xvalue.
glvalue 表示“有名字、有地址”（可取地址或能出现在赋值 = 左侧）的对象或子对象。
prvalue 表示临时的纯值，比如字面量、运算结果、函数返回非引用类型。
xvalue 表示即将被销毁的临时对象（资源可被“窃取”），如将亡的移动操作结果。

#### LVaule
左值，是指那些在内存中可以通过地址访问到的变量，通常也就是在代码中有标识符(identifier)的变量。其特点是可以进行取地址操作，通常可以出现在赋值运算符的左侧。

#### RVaule
纯右值通常是那些临时对象，字面量，运算结果等，他们没有持久的地址，通常不能对其进行取址。

```c++
int i = 42; // i is Lvaule, 42 is Rvalue
int *p = &i; // p is Lvaule, &i is Rvalue
```

#### LVaule Reference
最通俗的理解，左值引用是内存中某个对象的别名。
也可以理解为，**栈区对象的引用**相当于**堆区对象的指针**。当我们对引用做修改的时候，也就相当于对引用的对象做修改。
利用引用的好处是，省去了数据拷贝的步骤，提升了效率。

#### RVaule Reference
对于右值来说，我们通常没有办法通过它们的地址去访问他们。因此，C++11首次引入了右值引用的概念，可以允许用户去访问内存中的临时变量。

右值引用的写法如下：
```c++
int &&j = 42;
```
以上面的例子，当代码执行成功了之后，我们就可以访问内存中存储数字42的地址。因此，我们把临时右值42转换成了**左值变量**j，这种转换一直持续到右值引用失效为止。

使用右值引用的原因是，通过节省拷贝操作的开销提升程序运行效率。比如下面的赋值语句，在没有右值引用的情况下需要经过如下步骤。

```c++
int m = k + l; // m = Lvalue, l+k = Rvalue
```

    1. 在内存中创建左值变量m
    2. 计算k+l的和，并将结果按照右值存储在内存中
    3. 存储起来的临时变量被拷贝到m的地址中。在某个时刻，这个值被创建两次。
    4. 最后临时变量被释放，系统可以删除该变量


当使用右值引用的时候：

```c++
int &&m = k + l; // m = Rvalue Reference
```

1. 在内存中创建右值引用m
2. k+l计算结果临时变量的地址直接赋值给m，没有拷贝和销毁过程

#### Perfect Forwarding

动机：在**模板**里，你希望编写一个函数 wrapper，它能无损地把参数原封不动地“转发”给另一个函数 target，包括保留参数的左值/右值属性。

做法：模板参数写成 `T&&`.

```c++
template<typename T>
void wrapper(T&& arg) {
    target(std::forward<T>(arg));
}
```

调用 `std::forward<T>(arg)`的时候：

1. 如果原始实参是左值，T 推导为 X&，X& && 根据引用折叠规则会折叠成T&，那么 std::forward<T>(arg) 会变成 static_cast<X&>(arg) —— 传过去的是左值。
2. 如果原始实参是右值，T 推导为 X，那么 std::forward<T>(arg) 会变成 static_cast<X&&>(arg) —— 传过去的是右值。

使用完美转发的原因在于，有的类实现了移动构造函数，当传递右值到构造函数的时候，调用移动构造函数相对于拷贝构造函数要少很多开销。